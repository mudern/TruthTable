# 描述 Description

一个接收用户输入公式，输出真值表，主析取范式和主合取范式，公式类型的CPP程序。

A CPP program that receives user input formulas, outputs truth tables, main disjunction paradigms and principal conjunction paradigms, and formula types.

# 算法描述 Algorithm Description

算法设计上主要分为两大部分,一部分是解析用户输入,另一部分是解决真值计算与业务逻辑问题.

解析用户输入的核心在于将用户输入的中缀公式先转化为后缀公式,再将后缀公式转化为语法树方便进一步解析,在本程序中这两部分被拆解成`genRP()`和`genAST()`两个函数.这部分是编写本程序最大的难点,为此我查询了**Compilers: Principles, Techniques, and Tools**,快速学习了有关编译和语法树的知识,特此鸣谢作者Alfred V. Aho, Monica S. Lam Monica S. Lam,Ravi Sethi, and Jeffrey D. Ullman.

真值计算部分实现较为简单,由于之前架构上的简洁设计,这部分实现十分简单,主要分为两个部分,一部分是真值计算问题,另一部分是业务逻辑问题.真值计算部分的核心在于真值计算与对语法树的遍历,在本程序中这两部分被拆解为`calc()`,`parseAST()`,`genResult()`两个函数.业务逻辑的核心在于解析`parseAST()`和`genResult()`生成的二维结果向量并予以输出.

The algorithm design is mainly divided into two parts, one is to analyze user input, and the other is to solve truth calculation and business logic problems


The core of parsing user input is to first convert the infix formula into a suffix formula, and then convert the suffix formula into a syntax tree for further parsing. In this program, these two parts are decomposed into two functions: 'genRP()' and 'genAST()'. This is the biggest difficulty in writing this program. Therefore, I searched * * Compilers: Principles, Techniques, and Tools * * to quickly learn about compilation and syntax tree knowledge, Thank you to the authors Alfred V. Aho, Monica S. Lam, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman


The implementation of the truth calculation part is relatively simple. Due to the concise design of the previous architecture, this part is mainly divided into two parts: one is the truth calculation problem, and the other is the business logic problem. The core of the truth calculation part is the truth calculation and traversal of the syntax tree. In this program, these two parts are decomposed into 'calc()' and 'parseAST()', `The core of business logic lies in parsing the two-dimensional result vectors generated by 'parseAST()' and 'genResult()' and outputting them

# 函数描述 Function Description

## 解析输入 Parse input

1. 识别运算符与运算符等级 Identify operators and operator levels

为正确区分运算符和变元,正确判断运算符等级,我使用了结构体存储存储运算符及其对应等级,使用了函数遍历判断.

正确存储运算符等级这部分采用了结构体,用于存储运算符与其对应的等级.代码如下:


To correctly distinguish between operators and arguments, and to correctly determine operator levels, I used a structure to store and store operators and their corresponding levels, and used function traversal judgment


The correct storage of operator levels section uses a structure to store operators and their corresponding levels. The code is as follows:

```cPp
//定义运算符优先级对应的结构体
////Define the structure corresponding to operator priority
typedef struct oper_prio {  
    char oper;  
    int prio;  
} oper_prio;  
  
//存储运算符优先级的数组
//Array storing operator priority
const oper_prio ops[5] = {  
    {'!', 4},  
    {'&', 3},  
    {'|', 2},  
    {'-', 1},  
    {'+', 0}  
};  
  
  
//用于存放操作符  
//Used to store operators
const char opers[5] = {'!', '&', '|', '-', '+'};  
  
//用于存放二元运算符  
//Used to store binary operators
const char bin_opers[4] = {'&', '|', '-', '+'};
```

其中需要特别注意的是,因为一元运算符的语法树生成不同于二元运算符,二元运算符和一元运算符被区分开来.

正确判断运算符等级这部分采用了函数`priorityGR()`,通过解析用户输入的两个代表运算符的字符型变量查询其在上述结构体数组中对应的运算等级,返回等级比较结果.

代码如下:

 It should be noted that the syntax tree generation of unary  operators is different from that of binary operators, and binary and  unary operators are distinguished 

 The function `priorityGR()` is used to correctly determine  the operator level. By parsing the character type variables representing the operator input by the user, the corresponding operation level in  the above structure array is queried, and the level comparison result is returned 

 The code is as follows: 

```cPp
//判断运算符优先级  
//gr表示greater than缩写
//Determine operator priority
//Gr stands for greater than abbreviation 
bool priorityGR(char input1, char input2) {  
    int num1 = 0;  
    int num2 = 0;  
    //将输入字符转化为对应的等级
  	//Convert input characters to corresponding levels
    for (int i = 0; i < 5; i++) {  
        if (input1 == ops[i].oper) {  
            num1 = ops[i].prio;  
        }  
        if (input2 == ops[i].oper) {  
            num2 = ops[i].prio;  
        }  
    }  
    //返回等级比较结果 
  	//Return level comparison results
    return num1 > num2;  
}
```

正确判断运算符和二元运算符采用了函数`isBinOper()`和`isOper()`,通过解析用户输入的代表运算符的字符型变量是否存在于先前定义的数组中,实现对结果的判断.

代码如下:

 Correctly determining the operator and binary operator using  functions `isBinOper()` and `isOper()` , by parsing whether the  character type variable representing the operator entered by the user  exists in the previously defined array, the result is determined 

 The code is as follows: 

```cPp
//判断是否为二元运算符 
//Determine if it is a binary operator
bool isBinOper(char input) {  
    for (int i = 0; i < 4; i++) {  
        if (input == bin_opers[i]) {  
            return true;  
        }  
    }  
    return false;  
}  
  
//判断是否为运算符  
//Determine if it is an operator
bool isOper(char input) {  
    if (isBinOper(input) || input == '!') {  
        return true;  
    } else {  
        return false;  
    }  
}
```

2. 中缀表达式转化为后缀表达式 Convert infix expressions to suffix expressions 

这部分是解析用户输入核心其一.人类自然语言主谓宾的中缀表达方式对于计算机来说较难理解.这里我们先将用户输入转化为便于计算机理解的主宾谓的后缀表达(又被称为逆波兰式)方式,同时完成对符号优先级和括号优先级的解析.对于例子`((!p&q)|!r)&s`来说,其将会被转化为`p!q!&r!|s&`.

这部分采用的核心数据结构为栈,通过从左至右扫描用户输入,对于变元直接加入到结果字符串,操作符及括号压入栈中进行进一步处理,具体细节逻辑见代码注释.栈的实现采用了C++自带的STL库.

代码如下:

 This section is one of the core parts of parsing user input. The infix  expression of subject, predicate, and object in human natural language  is difficult for computers to understand. Here, we first convert user  input into a suffix expression of subject, predicate, and object that is easy for computers to understand (also known as reverse Polish style),  while completing the parsing of symbol priority and bracket priority.  For example `(! P&q) |! r)` For's', it will be converted to `p! q!& r!| s&`. 

 The core data structure used in this part is the stack. By  scanning user input from left to right, the arguments are directly added to the result string, operators and parentheses are pushed into the  stack for further processing. See the code notes for the specific  details of the logic. The stack is implemented using the STL library  provided with C++ 

 The code is as follows: 

```cPp
//将中缀语句生成为后缀语句  
//缩写generate为gen,Reverse Polish为RP 
//Generate infix statements as suffix statements
//The abbreviation 'generate' is' gen 'and' Reverse Polish 'is' RP'
string genRP(string input) {  
    //1.创建一个空的栈,用于存储运算符  
  	//1. Create an empty stack for storing operators
    stack<char> temp;  
    //创建结果存储和对应长度  
  	//Create result storage and corresponding length
    string res;  
    int length = input.size();  
    //2.从左到右遍历输入的算式,读取每个字符  
  	//2. Traverse the input formula from left to right, reading each character
    for (int i = 0; i < length; i++) {  
        /*  
          3.如果当前字符是一个运算符，那么比较其与栈顶运算符的优先级。  
          如果该运算符优先级较低，那么将栈顶运算符弹出并输出到输出队列中，  
          重复此步骤直到栈顶运算符优先级小于该运算符或栈为空。  
          然后将该运算符推入栈中。  
         */  
      	/*
          3. If the current character is an operator, compare its priority with the stack top operator.
          If the operator has a lower priority, pop up the stack top operator and output it to the output queue,
          Repeat this step until the top of the stack operator has a priority lower than that operator or the stack is empty.
          Then push the operator onto the stack.
					*/ 
        if (isOper(input[i])) {  
            while ((!temp.empty()) && (!priorityGR(input[i], temp.top()))) {  
                res.push_back(temp.top());  
                temp.pop();  
            }  
            temp.push(input[i]);  
        }  
        //4.如果当前字符是一个左括号,那么将其推入栈中
      	//4. If the current character is a left parenthesis, push it onto the stack
        else if (input[i] == '(') {  
            temp.push(input[i]);  
        }  
        //5.如果当前字符是一个右括号,那么将栈中的元素弹出  
        //将其输出到输出队列中,直到遇到左括号 
      	//5. If the current character is a right parenthesis, pop up the elements in the stack
				//Output it to the output queue until encountering the left parenthesis
        else if (input[i] == ')') {  
            while (temp.top() != '(') {  
                res.push_back(temp.top());  
                temp.pop();  
            }  
            temp.pop();  
        }  
        //6.如果当前字符是一个变元,那么将其输出到输出队列中  
      	//6. If the current character is an argument, output it to the output queue
        else {  
            argu.push_back(input[i]);  
            res.push_back(input[i]);  
        }  
    }  
    //将栈内剩余所有符号排空  
  	//Empty all remaining symbols in the stack
    while (!temp.empty()) {  
        res.push_back(temp.top());  
        temp.pop();  
    }  
    return res;  
}
```

3. 后缀表达式转化为语法树 Convert suffix expressions to syntax trees

以下关于语法树的解释来自[中文维基百科](https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9):

>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。

简单理解就是将人类语言转化为树状结构进行存储,其中树节点的左右孩子节点表示了主谓宾中的主宾,在本问题中即变元,树节点表示了主谓宾中的这部分理所当然的使用了树数据结构进行用户输入存储.特别的对于单元运算符`!`来说,我只设置了其左节点有效,右节点指向空值.在抽象语法树解析中,`!`将被视为与变元一致,只是在赋值过程中会被赋负值.对于例子`p!q!&r!|s&`,来说,其将会被转化为下图中所示的树状结构.

代码如下:


The following explanation about grammar trees comes from [Chinese Wikipedia]（ https://zh.wikipedia.org/zh-cn/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9 ):


>In computer science, Abstract Syntax Tree (AST), or simply Syntax Tree, is an abstract representation of the source code syntax structure. It presents the syntax structure of a programming language in a tree like form, with each node on the tree representing a structure in the source code.


A simple understanding is to transform human language into a tree like structure for storage, where the left and right child nodes of the tree node represent the subject object in the subject verb object, which in this problem is called an argument. The tree node represents this part of the subject verb object, which naturally uses a tree data structure for user input storage. Especially for the unit operator '` For example, I only set its left node to be valid, while the right node points to a null value. In abstract syntax tree parsing, '` Will be considered consistent with the argument, but will be assigned a negative value during the assignment process. For example ` p! q!& r!| For example, it will be transformed into a tree like structure as shown in the following figure


The code is as follows:

```cPp
//定义语法树数据结构  
//缩写Abstract Syntax Tree为AST  
//Define syntax tree data structure
//The abbreviation Abstract Syntax Tree is AST
typedef struct AST {  
    char data;  
    AST* leftChild;  
    AST* rightChild;  
}*treeNode;  
  
//将后缀语句转化为语法树  
//Convert suffix statements into syntax trees
treeNode genAST(string inputRP) {  
    //1.创建一个空栈用于存放节点  
  	//1. Create an empty stack for storing nodes
    stack<treeNode> temp;  
    //2.从左到右扫描逆波兰式  
  	//2. Scan reverse Polish from left to right
    int length = inputRP.size();  
    for (int i = 0; i < length; i++) {  
        //3.如果当前字符是运算符,则从栈中弹出两个节点,链接后推入栈中 
        //左右孩子为弹出节点,节点数据为运算符  
        //这里要对一元运算符单独判断,一元运算符则弹出一个节点  
      	//3. If the current character is an operator, pop up two nodes from the stack, link them, and push them onto the stack
				//The left and right children are pop-up nodes, and the node data is an operator
        if (isOper(inputRP[i])) {  
            treeNode t = new AST;  
            t->data = inputRP[i];  
            treeNode leftchild = temp.top();  
            t->leftChild = leftchild;  
            t->rightChild = leftchild;  
            temp.pop();  
            if (inputRP[i] != '!') {  
                treeNode rightchild = temp.top();  
                t->rightChild = rightchild;  
                temp.pop();  
            }  
            temp.push(t);  
        }  
        //4.如果当前字符是变元,则创建新节点并推入栈中  
        //左右孩子皆空,节点数据为变元  
      	//4. If the current character is an argument, create a new node and push it onto the stack
				//Both left and right children are empty, and the node data is an argument
        else {  
            treeNode t = new AST;  
            t->data = inputRP[i];  
            t->leftChild = nullptr;  
            t->rightChild = nullptr;  
            temp.push(t);  
        }  
    }  
    //5.遍历结束后栈中只剩下一个AST根节点,返回该节点  
  	//5. After traversal, there is only one AST root node left in the stack, and this node is returned
    return temp.top();  
}
```

## 真值计算 True value calculation

1. 运算符逻辑 Operator logic

这部分是实现简单真值计算,采用了函数`calc()`,通过对用户输入的运算符和两个变元真值,返回计算结果.

代码如下:


This section implements simple truth calculation by using the function 'calc()', which returns the calculation result based on the operator input by the user and the truth values of two arguments


The code is as follows:

```cpp
//输入运算符和两个变元,返回运算结果  
//!表示非运算,&表示与运算,|表示或运算,-表示蕴含运算,+表示等价运算
//Enter an operator and two arguments to return the result of the operation
//! Represents non operation,&represents AND operation, | represents OR operation, - represents implicative operation,+represents equivalent operation
bool calc(char oper, bool num1, bool num2) {  
    switch (oper) {  
        case '!':  
            return !num1;  
        case '&':  
            return num1 && num2;  
        case '|':  
            return num1 || num2;  
        case '-':  
            return !num1 || num2;  
        case '+':  
            return (!num1 || num2) && (!num2 || num1);  
    }  
    return false;  
}
```

其中,蕴含表达式和等值表达式,我采用了与其真值一致的`!num1 || num2`和`(!num1 || num2) && (!num2 || num1)`来进行处理,保持整体代码的简洁高效.

Among them, the implication expression and the equivalence expression, I used the '! Num1 | | num2 ` and ` (! Num1 | | num2)&&(! Num2 | | num1) ` are used for processing to maintain the overall code's simplicity and efficiency

2. 语法树计算 Grammar Tree Calculation

这部分是真值计算的核心,采用了函数`parseAST()`遍历先前生成的语法树并根据用户输入的为变量赋值数组计算语法树对应的公式的最终结果.同时特别的,这里单元运算符`!`将会被视作与变元一致,只是在赋值阶段会被赋负值.

这部分采用的核心数据结构是栈,将孩子节点不为变元或`!`的节点压入栈,直至孩子节点皆为变元或`!`,即树底位置,然后根据赋值顺序逐步向上回溯,将上一计算结果作为新值与下一赋值进行计算,直至所有节点计算完毕返回树顶.

具体实现逻辑见代码注释.代码如下:


This section is the core of truth calculation, using the function 'parseAST()' to traverse the previously generated syntax tree and calculate the final result of the formula corresponding to the syntax tree based on the array assigned to the variable by the user input. Additionally, the unit operator 'is used here` It will be considered consistent with the argument, but will be assigned a negative value during the assignment phase


The core data structure used in this section is the stack, which does not treat child nodes as arguments or '` The node is pushed onto the stack until all child nodes are arguments or '!', That is, the position at the bottom of the tree, and then gradually backtrack upwards according to the assignment order, calculating the previous calculation result as a new value with the next assignment until all nodes have completed their calculations and returned to the top of the tree


The specific implementation logic can be found in the code comments. The code is as follows:

```cPp
//输入语法树和对应的赋值数组计算算式结果  
//Input syntax tree and corresponding assignment array to calculate formula results 
bool parseAST(treeNode root, vector<bool> assign) {  
    stack<treeNode> temp;  
    treeNode t = root;  
    //如果左右节点不均为变元,则持续压栈  
  	//If the left and right nodes are not equally arguments, the stack is continuously pressed
    while (isBinOper(t->rightChild->data)) {  
        temp.push(t);  
        t = t->rightChild;  
    }  
    //定义计数器,按照指定赋值进行计算
  	//Define a counter and calculate it according to the specified assignment
    int counter = 0;  
    //通过变元数,限制循环次数  
  	//Limit the number of cycles through arguments
    int ar_size = argu.size();  
    //保存计算结果并作为下次计算初始值  
  	//Save the calculation result and use it as the initial value for the next calculation
    bool res = assign[counter++];  
    if (t->rightChild->data == '!') {  
        res = !res;  
    }  
    //如果左右节点均为变元到达树底,则开始计算  
  	//If both the left and right nodes are arguments and reach the bottom of the tree, the calculation begins
    while (counter < ar_size) {  
        //输入两个初始值,上次计算结果语指定赋值 
      	//Enter two initial values, and assign the specified value to the last calculation result
        bool ass = assign[counter++];  
        if (t->leftChild->data == '!') {  
            ass = !ass;  
        }  
        res = calc(t->data, res, ass);  
        if (!temp.empty()) {  
            t = temp.top();  
            temp.pop();  
        }  
    }  
    return res;  
}
```

## 业务逻辑  Functional logic 

本次实验主要有三个主要的业务逻辑需要实现,分别是生成真值表,生成主析取范式和主合取范式,判断公式类型.接下来将逐步讲解业务逻辑实现过程.

In this experiment, there are three main business logics to be implemented, namely, generating the truth table, generating the main disjunctive normal form and the main conjunctive normal form, and judging the formula type. Next, we will explain the implementation process of business logic step by step

1. 生成赋值数组并存储结果 Generate an assignment array and store the results

这部分是上述三个业务实现的核心,采用了函数`genResult()`实现了赋值数组的生成与最终结果的计算.

首先是赋值数组生成,本部分没有采用递归方式,而是采用了位运算算法来高效安全的生成不重复的赋值数组.核心逻辑在于对$0$到$2^{n}$($n$表示变元个数),转化为二进制数并存入赋值数组作为赋值依据.这部分我原本想要使用递归算法,但是久久没有写出,在复习离散数学极大项极小项的过程中获得灵感,采用了上述算法,自认为是亮点之一.

其次是存储结果,语法树和赋值数组将作为参数输入到上述所说的函数`parseAST()`中计算最终结果存入到二维向量`truth_res`作为后续所有业务逻辑实现的凭靠.

代码如下:


This section is the core of the three business implementations mentioned above, using the function '`genResult()`' to generate assignment arrays and calculate the final results


The first is the generation of assignment array. Instead of recursion, this part uses a bit operation algorithm to efficiently and safely generate non repetitive assignment array. The core logic is to convert $0 $to $2 ^ {n} $($n $represents the number of arguments) into binary numbers and store them in the assignment array as the basis for assignment. I originally wanted to use the recursive algorithm, but I haven't written it for a long time. I got inspiration in reviewing the maximum and minimum terms of discrete mathematics, The adoption of the above algorithm is considered one of the highlights


The second step is to store the results. The syntax tree and assignment array will be input as parameters into the function '`parseAST()`' mentioned above, and the final result will be calculated and stored in the two-dimensional vector 'truth'_ Res' serves as the basis for the implementation of all subsequent business logic


The code is as follows:

```cPp
//生成赋值数组并计算真值表内容  
//存储计算结果  
//Generate assignment array and calculate the content of truth table
//Store calculation results 
vector<vector<bool>> truth_res;  
  
//生成赋值数组并计算最终结果存储结果向量  
//Generate an assignment array and calculate the final result storage result vector
void genResult(treeNode root) {  
    //计算赋值种类数并其进行二进制解析  
  	//Calculate the number of assigned types and perform binary parsing on them
    int argu_size = argu.size();  
    int assign_num = pow(2, argu.size());  
    truth_res.resize(assign_num, vector<bool>(argu_size + 1));  
    //对所有赋值种类进行遍历  
  	//Traverse all assignment types
    for (int i = 0; i < assign_num; i++) {  
        //对每一种赋值情况拆解成二进制数  
        //这样既可以保证内存安全,也可以高效遍历所有情况  
      	//Decompose each assignment into binary numbers
        //This can ensure memory security and efficiently traverse all situations
        vector<bool> assign;  
        int counter = 0;  
        for (int j = 0; j < argu_size; j++) {  
            //使用位运算拆解成二进制数作为赋值
          	//Using bit operations to decompose into binary numbers for assignment
            bool temp = i >> j & 1;  
            truth_res[i][counter++] = temp;  
            assign.push_back(temp);  
        }  
        bool res = parseAST(root, assign);  
        truth_res[i][counter++] = res;  
    }  
}
```

2. DNF和CNF生成 DNF and CNF generation 

这部分是根据上述的二维结果向量生成主析取和主合取范式.由于主析取范式和主合取范式生成极为相似,所以这里以主析取范式为例.核心逻辑在于检查二维结果向量中的结果,如果结果为$1$,则用于生成主析取范式,检查变量值,如果某个输入变量为1,则直接写下这个变量,如果某个输入变量为0,则写下这个变量的非用`&`符号连接生成子部分,将子部分用`|`连接生成最终结果.

代码如下:

 This part is to generate the main disjunctive form and the main conjunctive  normal form according to the two-dimensional result vector mentioned  above. Since the main disjunctive normal form and the main conjunctive  normal form are very similar, the main disjunctive normal form is taken  as an example here. The core logic is to check the results in the  two-dimensional result vector. If the result is $1 $, it is used to  generate the main disjunctive normal form and check the value of the  variable. If an input variable is 1, it is directly written down. If an  input variable is 0, Then write down the non use of the '&' symbol to concatenate the  variable to generate a sub part, and use the '|' symbol to concatenate  the sub parts to generate the final result 

 The code is as follows: 

```cPp
/*  
  通过genResult生成的二维向量来进行主析取范式和主合取范式的生成  
  由于生成主析取范式和主合取范式十分相似  
  这里只以生成主析取范式函数genDNF注释为例  
 */  
/*
Generate the main disjunctive normal form and main conjunctive normal form through the two-dimensional vector generated by genResult
Because the generative main disjunctive normal form is very similar to the main conjunctive normal form
Here, we only take the generation of the main disjunctive normal form function genDNF annotation as an example
*/ 
//根据结果数组生成主析取范式DNF  
//Generate the main disjunction normal form DNF based on the result array
string genDNF() {  
    string res ;  
    int argu_size = argu.size();  
    int assign_num = pow(2, argu.size());  
    int counter = 0;  
    for (int i = 0; i < assign_num; i++) {  
        //查看真值表中所有输出为1的行
      	//View all rows in the truth table with output of 1
        if (truth_res[i][argu_size] == 1) {  
            counter++;  
            if (counter != 1) {  
                res.push_back('|');  
            }  
            res.push_back('(');  
            for (int j = 0; j < argu_size; j++) {  
                if (j != 0) {  
                    res.push_back('&');  
                }  
                //如果某个输入变量为1,则直接写下这个变量  
                //如果某个输入变量为0,则写下这个变量的非 
              	//If an input variable is 1, write down the variable directly
                //If an input variable is 0, write the non
                if (truth_res[i][j] != 1) {  
                    res.push_back('!');  
                }  
                res.push_back(argu[j]);  
            }  
            res.push_back(')');  
        }  
    }  
    //将结果用|进行连接,形成主析取范式 
  	//Connect the results with | to form the main disjunction paradigm
    return res;  
}
```

3. 公式类型生成 Formula Type Generation

这部分是根据上述的二维结果向量生成解释公式类型的字符串.核心逻辑在于检查二维结果向量中的结果,如果全部为$0$则为永假式,如果存在$1$则为可满足式,如果全部为$1$则式可满足式中特殊的永真式.

代码如下:


This section generates a string explaining the formula type based on the two-dimensional result vector mentioned above. The core logic is to check the results in the two-dimensional result vector. If all of them are $0 $, it is a permanent false expression, if there is $1 $, it is a satisfying expression, and if all of them are $1 $, the formula can satisfy the special permanent true expression in the formula


The code is as follows:

```cPp
//生成输入公式类型  
//通过genResult生成的二维向量来进行公式类型判断
//Generate Input Formula Type
//Determine formula type using the two-dimensional vector generated by genResult

string genType(){  
    int argu_size = argu.size();  
    int assign_num = pow(2, argu.size());  
    int counter = 0;  
    string type;  
    for (int i = 0; i < assign_num; i++) {  
        if (truth_res[i][argu_size ] == 1) {  
            counter++;  
        }  
    }  
    if (counter == 0) {  
        type.append("输入公式为永假式");  
            }  
    if (counter < assign_num && counter != 0) {  
        if (counter == assign_num) {  
            type.append("输入公式为可满足式中的永真式");  
        }else{  
            type.append("输入公式为可满足式");  
        }  
    }  
    return type;  
}
```

## 打印 Print

本部分是对上述所有的生成结果进行打印表示,主要有打印真值表的`printHeader()`和`printTable()`函数,打印主析取范式和主合取范式的`printDNF()`和`printCNF()`函数,打印公式类型的`printType()`函数.

This section is to print all the above generated results, mainly including the 'printHeader()' and 'printTable()' functions of the print truth table, the 'printDNF()' and 'printCNF()' functions of the print main disjunctive normal form and main conjunctive normal form, and the 'printType()' function of the print formula type

1. 打印真值表 Print the truth table

打印真值表分为打印表头的`printHeader()`函数和`printTable()`函数.

首先是打印表头,打印表头核心在于遍历变元数组和用户输入字符串.其中核心在于根据用户输入不同,判断输入长度动态调节表格大小.

其次是打印表内容,打印表内容核心在于遍历上述的二维结果向量并进行打印.

代码如下:


Printing a truth table is divided into the '`printHeader()`' function and the '`printTable()`' function of the print header


The first step is to print the table header. The core of printing the table header lies in traversing the array of variables and the user input string. The core lies in dynamically adjusting the table size based on the input length of different users


The second step is to print the table content, which lies in traversing the two-dimensional result vectors mentioned above and printing them


The code is as follows:

```cPp
//以下为打印函数内容,用于输出指定内容  
//打印真值表表头  
//The following is the content of the print function, used to output the specified content
//Print truth table header
void printHeader(string input) {  
    int argu_size = argu.size();  
    for (int i = 0; i < argu_size; i++) {  
        cout << argu[i] << " | ";  
    }  
    cout << input << endl;  
    // 打印分隔线  
  	//Print divider lines
    for (int i = 0; i < argu_size; i++) {  
        cout << "--|-";  
    }  
    int input_size = input.size();  
    for (int i = 0; i < input_size; i++) {  
        cout << "-" ;  
    }  
    cout << endl;  
    return;  
}  
  
//根据结果数组打印真值表内容
//Print the contents of the truth table according to the result array
void printTable() {  
    //计算赋值种类数并其进行二进制解析
  	//Calculate the number of assigned types and perform binary parsing on them

    int argu_size = argu.size();  
    int assign_num = pow(2, argu.size());  
    for (int i = 0; i < assign_num; i++) {  
        for (int j = 0; j < argu_size; j++) {  
            cout << truth_res[i][j] << " | ";  
        }  
        cout << truth_res[i][argu_size] << endl;  
    }  
    return;  
}
```

2. 打印DNF,CNF和公式类型 Print DNF, CNF, and formula types

这部分代码只需调用上述的`genDNF()`,`genCNF()`和`genType()`,并输出这些函数的生成的字符串即可.

代码如下:


This part of the code only needs to call the aforementioned '`genDNF()`', '`genCNF()`', and '`genType()`', and output the generated strings of these functions


The code is as follows:

```cPp
//根据结果打印主析取范式
//Print the main disjunction paradigm based on the results
void printDNF() {  
    cout << "主析取范式为:" << endl;  
    cout << genDNF() << endl;  
    return;  
}  
//根据结果打印主合取范式  
//Print the main conjunctive normal form according to the results
void printCNF() {  
    cout << "主合取范式为:" << endl;  
    cout << genCNF() << endl;  
    return;  
}  
  
//根据结果数组打印公式类型  
//Print formula types based on result arrays
void printType() {  
    cout<<genType()<<endl;  
}